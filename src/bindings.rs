/* automatically generated by rust-bindgen 0.59.1 */

pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 31;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LONG_DOUBLE_USES_FLOAT128: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rtlsdr_dev {
    _unused: [u8; 0],
}
pub type rtlsdr_dev_t = rtlsdr_dev;
extern "C" {
    pub fn rtlsdr_get_device_count() -> u32;
}
extern "C" {
    pub fn rtlsdr_get_device_name(index: u32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get USB device strings."]
    #[doc = ""]
    #[doc = " NOTE: The string arguments must provide space for up to 256 bytes."]
    #[doc = ""]
    #[doc = " \\param index the device index"]
    #[doc = " \\param manufact manufacturer name, may be NULL"]
    #[doc = " \\param product product name, may be NULL"]
    #[doc = " \\param serial serial number, may be NULL"]
    #[doc = " \\return 0 on success"]
    pub fn rtlsdr_get_device_usb_strings(
        index: u32,
        manufact: *mut ::std::os::raw::c_char,
        product: *mut ::std::os::raw::c_char,
        serial: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get device index by USB serial string descriptor."]
    #[doc = ""]
    #[doc = " \\param serial serial string of the device"]
    #[doc = " \\return device index of first device where the name matched"]
    #[doc = " \\return -1 if name is NULL"]
    #[doc = " \\return -2 if no devices were found at all"]
    #[doc = " \\return -3 if devices were found, but none with matching name"]
    pub fn rtlsdr_get_index_by_serial(
        serial: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rtlsdr_open(dev: *mut *mut rtlsdr_dev_t, index: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rtlsdr_close(dev: *mut rtlsdr_dev_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set crystal oscillator frequencies used for the RTL2832 and the tuner IC."]
    #[doc = ""]
    #[doc = " Usually both ICs use the same clock. Changing the clock may make sense if"]
    #[doc = " you are applying an external clock to the tuner or to compensate the"]
    #[doc = " frequency (and samplerate) error caused by the original (cheap) crystal."]
    #[doc = ""]
    #[doc = " NOTE: Call this function only if you fully understand the implications."]
    #[doc = ""]
    #[doc = " \\param dev the device handle given by rtlsdr_open()"]
    #[doc = " \\param rtl_freq frequency value used to clock the RTL2832 in Hz"]
    #[doc = " \\param tuner_freq frequency value used to clock the tuner IC in Hz"]
    #[doc = " \\return 0 on success"]
    pub fn rtlsdr_set_xtal_freq(
        dev: *mut rtlsdr_dev_t,
        rtl_freq: u32,
        tuner_freq: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get crystal oscillator frequencies used for the RTL2832 and the tuner IC."]
    #[doc = ""]
    #[doc = " Usually both ICs use the same clock."]
    #[doc = ""]
    #[doc = " \\param dev the device handle given by rtlsdr_open()"]
    #[doc = " \\param rtl_freq frequency value used to clock the RTL2832 in Hz"]
    #[doc = " \\param tuner_freq frequency value used to clock the tuner IC in Hz"]
    #[doc = " \\return 0 on success"]
    pub fn rtlsdr_get_xtal_freq(
        dev: *mut rtlsdr_dev_t,
        rtl_freq: *mut u32,
        tuner_freq: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get USB device strings."]
    #[doc = ""]
    #[doc = " NOTE: The string arguments must provide space for up to 256 bytes."]
    #[doc = ""]
    #[doc = " \\param dev the device handle given by rtlsdr_open()"]
    #[doc = " \\param manufact manufacturer name, may be NULL"]
    #[doc = " \\param product product name, may be NULL"]
    #[doc = " \\param serial serial number, may be NULL"]
    #[doc = " \\return 0 on success"]
    pub fn rtlsdr_get_usb_strings(
        dev: *mut rtlsdr_dev_t,
        manufact: *mut ::std::os::raw::c_char,
        product: *mut ::std::os::raw::c_char,
        serial: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write the device EEPROM"]
    #[doc = ""]
    #[doc = " \\param dev the device handle given by rtlsdr_open()"]
    #[doc = " \\param data buffer of data to be written"]
    #[doc = " \\param offset address where the data should be written"]
    #[doc = " \\param len length of the data"]
    #[doc = " \\return 0 on success"]
    #[doc = " \\return -1 if device handle is invalid"]
    #[doc = " \\return -2 if EEPROM size is exceeded"]
    #[doc = " \\return -3 if no EEPROM was found"]
    pub fn rtlsdr_write_eeprom(
        dev: *mut rtlsdr_dev_t,
        data: *mut u8,
        offset: u8,
        len: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read the device EEPROM"]
    #[doc = ""]
    #[doc = " \\param dev the device handle given by rtlsdr_open()"]
    #[doc = " \\param data buffer where the data should be written"]
    #[doc = " \\param offset address where the data should be read from"]
    #[doc = " \\param len length of the data"]
    #[doc = " \\return 0 on success"]
    #[doc = " \\return -1 if device handle is invalid"]
    #[doc = " \\return -2 if EEPROM size is exceeded"]
    #[doc = " \\return -3 if no EEPROM was found"]
    pub fn rtlsdr_read_eeprom(
        dev: *mut rtlsdr_dev_t,
        data: *mut u8,
        offset: u8,
        len: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rtlsdr_set_center_freq(dev: *mut rtlsdr_dev_t, freq: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get actual frequency the device is tuned to."]
    #[doc = ""]
    #[doc = " \\param dev the device handle given by rtlsdr_open()"]
    #[doc = " \\return 0 on error, frequency in Hz otherwise"]
    pub fn rtlsdr_get_center_freq(dev: *mut rtlsdr_dev_t) -> u32;
}
extern "C" {
    #[doc = " Set the frequency correction value for the device."]
    #[doc = ""]
    #[doc = " \\param dev the device handle given by rtlsdr_open()"]
    #[doc = " \\param ppm correction value in parts per million (ppm)"]
    #[doc = " \\return 0 on success"]
    pub fn rtlsdr_set_freq_correction(
        dev: *mut rtlsdr_dev_t,
        ppm: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get actual frequency correction value of the device."]
    #[doc = ""]
    #[doc = " \\param dev the device handle given by rtlsdr_open()"]
    #[doc = " \\return correction value in parts per million (ppm)"]
    pub fn rtlsdr_get_freq_correction(dev: *mut rtlsdr_dev_t) -> ::std::os::raw::c_int;
}
pub const rtlsdr_tuner_RTLSDR_TUNER_UNKNOWN: rtlsdr_tuner = 0;
pub const rtlsdr_tuner_RTLSDR_TUNER_E4000: rtlsdr_tuner = 1;
pub const rtlsdr_tuner_RTLSDR_TUNER_FC0012: rtlsdr_tuner = 2;
pub const rtlsdr_tuner_RTLSDR_TUNER_FC0013: rtlsdr_tuner = 3;
pub const rtlsdr_tuner_RTLSDR_TUNER_FC2580: rtlsdr_tuner = 4;
pub const rtlsdr_tuner_RTLSDR_TUNER_R820T: rtlsdr_tuner = 5;
pub const rtlsdr_tuner_RTLSDR_TUNER_R828D: rtlsdr_tuner = 6;
pub type rtlsdr_tuner = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Get the tuner type."]
    #[doc = ""]
    #[doc = " \\param dev the device handle given by rtlsdr_open()"]
    #[doc = " \\return RTLSDR_TUNER_UNKNOWN on error, tuner type otherwise"]
    pub fn rtlsdr_get_tuner_type(dev: *mut rtlsdr_dev_t) -> rtlsdr_tuner;
}
extern "C" {
    #[doc = " Get a list of gains supported by the tuner."]
    #[doc = ""]
    #[doc = " NOTE: The gains argument must be preallocated by the caller. If NULL is"]
    #[doc = " being given instead, the number of available gain values will be returned."]
    #[doc = ""]
    #[doc = " \\param dev the device handle given by rtlsdr_open()"]
    #[doc = " \\param gains array of gain values. In tenths of a dB, 115 means 11.5 dB."]
    #[doc = " \\return <= 0 on error, number of available (returned) gain values otherwise"]
    pub fn rtlsdr_get_tuner_gains(
        dev: *mut rtlsdr_dev_t,
        gains: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the gain for the device."]
    #[doc = " Manual gain mode must be enabled for this to work."]
    #[doc = ""]
    #[doc = " Valid gain values (in tenths of a dB) for the E4000 tuner:"]
    #[doc = " -10, 15, 40, 65, 90, 115, 140, 165, 190,"]
    #[doc = " 215, 240, 290, 340, 420, 430, 450, 470, 490"]
    #[doc = ""]
    #[doc = " Valid gain values may be queried with \\ref rtlsdr_get_tuner_gains function."]
    #[doc = ""]
    #[doc = " \\param dev the device handle given by rtlsdr_open()"]
    #[doc = " \\param gain in tenths of a dB, 115 means 11.5 dB."]
    #[doc = " \\return 0 on success"]
    pub fn rtlsdr_set_tuner_gain(
        dev: *mut rtlsdr_dev_t,
        gain: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the bandwidth for the device."]
    #[doc = ""]
    #[doc = " \\param dev the device handle given by rtlsdr_open()"]
    #[doc = " \\param bw bandwidth in Hz. Zero means automatic BW selection."]
    #[doc = " \\return 0 on success"]
    pub fn rtlsdr_set_tuner_bandwidth(dev: *mut rtlsdr_dev_t, bw: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get actual gain the device is configured to."]
    #[doc = ""]
    #[doc = " \\param dev the device handle given by rtlsdr_open()"]
    #[doc = " \\return 0 on error, gain in tenths of a dB, 115 means 11.5 dB."]
    pub fn rtlsdr_get_tuner_gain(dev: *mut rtlsdr_dev_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the intermediate frequency gain for the device."]
    #[doc = ""]
    #[doc = " \\param dev the device handle given by rtlsdr_open()"]
    #[doc = " \\param stage intermediate frequency gain stage number (1 to 6 for E4000)"]
    #[doc = " \\param gain in tenths of a dB, -30 means -3.0 dB."]
    #[doc = " \\return 0 on success"]
    pub fn rtlsdr_set_tuner_if_gain(
        dev: *mut rtlsdr_dev_t,
        stage: ::std::os::raw::c_int,
        gain: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the gain mode (automatic/manual) for the device."]
    #[doc = " Manual gain mode must be enabled for the gain setter function to work."]
    #[doc = ""]
    #[doc = " \\param dev the device handle given by rtlsdr_open()"]
    #[doc = " \\param manual gain mode, 1 means manual gain mode shall be enabled."]
    #[doc = " \\return 0 on success"]
    pub fn rtlsdr_set_tuner_gain_mode(
        dev: *mut rtlsdr_dev_t,
        manual: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the sample rate for the device, also selects the baseband filters"]
    #[doc = " according to the requested sample rate for tuners where this is possible."]
    #[doc = ""]
    #[doc = " \\param dev the device handle given by rtlsdr_open()"]
    #[doc = " \\param samp_rate the sample rate to be set, possible values are:"]
    #[doc = " \t\t    225001 - 300000 Hz"]
    #[doc = " \t\t    900001 - 3200000 Hz"]
    #[doc = " \t\t    sample loss is to be expected for rates > 2400000"]
    #[doc = " \\return 0 on success, -EINVAL on invalid rate"]
    pub fn rtlsdr_set_sample_rate(dev: *mut rtlsdr_dev_t, rate: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get actual sample rate the device is configured to."]
    #[doc = ""]
    #[doc = " \\param dev the device handle given by rtlsdr_open()"]
    #[doc = " \\return 0 on error, sample rate in Hz otherwise"]
    pub fn rtlsdr_get_sample_rate(dev: *mut rtlsdr_dev_t) -> u32;
}
extern "C" {
    #[doc = " Enable test mode that returns an 8 bit counter instead of the samples."]
    #[doc = " The counter is generated inside the RTL2832."]
    #[doc = ""]
    #[doc = " \\param dev the device handle given by rtlsdr_open()"]
    #[doc = " \\param test mode, 1 means enabled, 0 disabled"]
    #[doc = " \\return 0 on success"]
    pub fn rtlsdr_set_testmode(
        dev: *mut rtlsdr_dev_t,
        on: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enable or disable the internal digital AGC of the RTL2832."]
    #[doc = ""]
    #[doc = " \\param dev the device handle given by rtlsdr_open()"]
    #[doc = " \\param digital AGC mode, 1 means enabled, 0 disabled"]
    #[doc = " \\return 0 on success"]
    pub fn rtlsdr_set_agc_mode(
        dev: *mut rtlsdr_dev_t,
        on: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enable or disable the direct sampling mode. When enabled, the IF mode"]
    #[doc = " of the RTL2832 is activated, and rtlsdr_set_center_freq() will control"]
    #[doc = " the IF-frequency of the DDC, which can be used to tune from 0 to 28.8 MHz"]
    #[doc = " (xtal frequency of the RTL2832)."]
    #[doc = ""]
    #[doc = " \\param dev the device handle given by rtlsdr_open()"]
    #[doc = " \\param on 0 means disabled, 1 I-ADC input enabled, 2 Q-ADC input enabled"]
    #[doc = " \\return 0 on success"]
    pub fn rtlsdr_set_direct_sampling(
        dev: *mut rtlsdr_dev_t,
        on: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get state of the direct sampling mode"]
    #[doc = ""]
    #[doc = " \\param dev the device handle given by rtlsdr_open()"]
    #[doc = " \\return -1 on error, 0 means disabled, 1 I-ADC input enabled"]
    #[doc = "\t    2 Q-ADC input enabled"]
    pub fn rtlsdr_get_direct_sampling(dev: *mut rtlsdr_dev_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enable or disable offset tuning for zero-IF tuners, which allows to avoid"]
    #[doc = " problems caused by the DC offset of the ADCs and 1/f noise."]
    #[doc = ""]
    #[doc = " \\param dev the device handle given by rtlsdr_open()"]
    #[doc = " \\param on 0 means disabled, 1 enabled"]
    #[doc = " \\return 0 on success"]
    pub fn rtlsdr_set_offset_tuning(
        dev: *mut rtlsdr_dev_t,
        on: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get state of the offset tuning mode"]
    #[doc = ""]
    #[doc = " \\param dev the device handle given by rtlsdr_open()"]
    #[doc = " \\return -1 on error, 0 means disabled, 1 enabled"]
    pub fn rtlsdr_get_offset_tuning(dev: *mut rtlsdr_dev_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rtlsdr_reset_buffer(dev: *mut rtlsdr_dev_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rtlsdr_read_sync(
        dev: *mut rtlsdr_dev_t,
        buf: *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        n_read: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type rtlsdr_read_async_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        buf: *mut ::std::os::raw::c_uchar,
        len: u32,
        ctx: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " Read samples from the device asynchronously. This function will block until"]
    #[doc = " it is being canceled using rtlsdr_cancel_async()"]
    #[doc = ""]
    #[doc = " NOTE: This function is deprecated and is subject for removal."]
    #[doc = ""]
    #[doc = " \\param dev the device handle given by rtlsdr_open()"]
    #[doc = " \\param cb callback function to return received samples"]
    #[doc = " \\param ctx user specific context to pass via the callback function"]
    #[doc = " \\return 0 on success"]
    pub fn rtlsdr_wait_async(
        dev: *mut rtlsdr_dev_t,
        cb: rtlsdr_read_async_cb_t,
        ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read samples from the device asynchronously. This function will block until"]
    #[doc = " it is being canceled using rtlsdr_cancel_async()"]
    #[doc = ""]
    #[doc = " \\param dev the device handle given by rtlsdr_open()"]
    #[doc = " \\param cb callback function to return received samples"]
    #[doc = " \\param ctx user specific context to pass via the callback function"]
    #[doc = " \\param buf_num optional buffer count, buf_num * buf_len = overall buffer size"]
    #[doc = "\t\t  set to 0 for default buffer count (15)"]
    #[doc = " \\param buf_len optional buffer length, must be multiple of 512,"]
    #[doc = "\t\t  should be a multiple of 16384 (URB size), set to 0"]
    #[doc = "\t\t  for default buffer length (16 * 32 * 512)"]
    #[doc = " \\return 0 on success"]
    pub fn rtlsdr_read_async(
        dev: *mut rtlsdr_dev_t,
        cb: rtlsdr_read_async_cb_t,
        ctx: *mut ::std::os::raw::c_void,
        buf_num: u32,
        buf_len: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Cancel all pending asynchronous operations on the device."]
    #[doc = ""]
    #[doc = " \\param dev the device handle given by rtlsdr_open()"]
    #[doc = " \\return 0 on success"]
    pub fn rtlsdr_cancel_async(dev: *mut rtlsdr_dev_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enable or disable the bias tee on GPIO PIN 0."]
    #[doc = ""]
    #[doc = " \\param dev the device handle given by rtlsdr_open()"]
    #[doc = " \\param on  1 for Bias T on. 0 for Bias T off."]
    #[doc = " \\return -1 if device is not initialized. 0 otherwise."]
    pub fn rtlsdr_set_bias_tee(
        dev: *mut rtlsdr_dev_t,
        on: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enable or disable the bias tee on the given GPIO pin."]
    #[doc = ""]
    #[doc = " \\param dev the device handle given by rtlsdr_open()"]
    #[doc = " \\param gpio the gpio pin to configure as a Bias T control."]
    #[doc = " \\param on  1 for Bias T on. 0 for Bias T off."]
    #[doc = " \\return -1 if device is not initialized. 0 otherwise."]
    pub fn rtlsdr_set_bias_tee_gpio(
        dev: *mut rtlsdr_dev_t,
        gpio: ::std::os::raw::c_int,
        on: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
